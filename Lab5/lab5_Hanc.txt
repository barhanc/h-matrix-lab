import random
import numpy as np
import matplotlib.pyplot as plt

from scipy.linalg import svd
from numpy.linalg import norm
from time import perf_counter
from sklearn.utils.extmath import randomized_svd


class Node:
    def __init__(self, rank=None, side=None, sMin=None, tMin=None, U=None, V=None, D=None):
        self.next: list[Node] = []

        self.sMin: int = sMin
        self.tMin: int = tMin
        self.side: int = side

        self.rank: int = rank
        self.U: np.ndarray[float] = U
        self.D: np.ndarray[float] = D
        self.V: np.ndarray[float] = V


def CompressMatrix(
    A: np.ndarray[float],
    U: np.ndarray[float],
    D: np.ndarray[float],
    V: np.ndarray[float],
    r: int,
    sMin: int,
    tMin: int,
):
    if np.allclose(A, np.zeros(A.shape)):
        return Node(rank=0, side=A.shape[0], sMin=sMin, tMin=tMin)

    return Node(
        rank=r,
        side=A.shape[0],
        sMin=sMin,
        tMin=tMin,
        U=U[:, :r],
        D=D[:r],
        V=V[:r, :],
    )


def CreateTree(A: np.ndarray[float], r: int, eps: float, sMin: int = 0, tMin: int = 0):
    n = A.shape[0]
    U, D, V = randomized_svd(A, r + 1)
    if len(D) <= r or D[r] < eps:
        v = CompressMatrix(A, U, D, V, len(D), sMin, tMin)
    else:
        v = Node(rank=None, side=n, sMin=sMin, tMin=tMin)
        v.next.append(CreateTree(A[: n // 2, : n // 2], r, eps, sMin, tMin))
        v.next.append(CreateTree(A[: n // 2, n // 2 :], r, eps, sMin, tMin + n // 2))
        v.next.append(CreateTree(A[n // 2 :, : n // 2], r, eps, sMin + n // 2, tMin))
        v.next.append(CreateTree(A[n // 2 :, n // 2 :], r, eps, sMin + n // 2, tMin + n // 2))
    return v


def DrawTree(root: Node):
    n = root.side
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_aspect("equal", "box")
    ax.set_xlim(0, n)
    ax.set_ylim(0, n)
    ax.set_title(r"$n=$" + f"{n}")

    def DrawTreeRecursive(root: Node):
        nonlocal ax

        if root.rank is None:  # Not a leaf -> draw grid lines
            x, y, d = root.sMin, root.tMin, root.side // 2
            ax.plot((x, x + 2 * d), (y + d, y + d), color="k", lw=0.6)
            ax.plot((x + d, x + d), (y, y + 2 * d), color="k", lw=0.6)

        elif root.rank > 0:  # Leaf with SVD decomposition -> fill block
            x, y, d = (root.sMin, root.tMin + root.side, root.side)
            lw = root.side / (6 * root.rank)
            for i in range(root.rank):
                ax.fill([x, x + d, x + d, x], [y, y, y - (i + 1) * lw, y - (i + 1) * lw], color="k")
                ax.fill([x, x + (i + 1) * lw, x + (i + 1) * lw, x], [y, y, y - d, y - d], color="k")

        elif root.rank == 0:  # Leaf with all 0s -> pass
            pass

        for node in root.next:
            DrawTreeRecursive(node)

    DrawTreeRecursive(root)
    return fig


def Decompress(root: Node):
    n = root.side
    A = np.zeros((n, n))

    def DecompressRecursive(root: Node):
        nonlocal A
        if root.rank is None:  # Not a leaf -> pass
            pass
        elif root.rank == 0:  # Leaf with all 0s -> pass
            pass
        elif root.rank > 0:
            s, t, side = root.sMin, root.tMin, root.side
            U, D, V = root.U, np.diag(root.D), root.V
            A[s : s + side, t : t + side] = U @ D @ V

        for node in root.next:
            DecompressRecursive(node)

    DecompressRecursive(root)
    return A


import matplotlib.pyplot as plt
import numpy as np
import random

from hmatrix import *
from collections import deque

%matplotlib inline
%config InlineBackend.figure_format = 'retina'
plt.rcParams["figure.figsize"] = [16, 9]
plt.style.use('default')

As = []

for w in (4, 8, 16):
    A = np.zeros((w**3, w**3))
    ind = lambda i, j, k: i + w * j + w**2 * k
    for i in range(w):
        for j in range(w):
            for k in range(w):
                A[ind(i, j, k), ind(i, j, k)] = random.random()
                if i - 1 >= 0:
                    A[ind(i, j, k), ind(i - 1, j, k)] = random.random()
                if i + 1 < w:
                    A[ind(i, j, k), ind(i + 1, j, k)] = random.random()
                if j - 1 >= 0:
                    A[ind(i, j, k), ind(i, j - 1, k)] = random.random()
                if j + 1 < w:
                    A[ind(i, j, k), ind(i, j + 1, k)] = random.random()
                if k - 1 >= 0:
                    A[ind(i, j, k), ind(i, j, k - 1)] = random.random()
                if k + 1 < w:
                    A[ind(i, j, k), ind(i, j, k + 1)] = random.random()
    As.append(A)

for i, A in enumerate(As):
    DrawTree(CreateTree(A, r=1, eps=1e-3)).savefig(f"{i}_bp_hm.png")

def mvmult(v: Node, X: np.ndarray, rev=False) -> np.ndarray:
    if not v.next:
        if v.rank == 0:
            return np.zeros(X.shape)
        if rev:
            return X @ v.U @ np.diag(v.D) @ v.V
        return v.U @ np.diag(v.D) @ v.V @ X

    k = X.shape[1] if rev else X.shape[0]
    X1 = X[:, : k // 2] if rev else X[: k // 2, :]
    X2 = X[:, k // 2 :] if rev else X[k // 2 :, :]

    Y11 = mvmult(v.next[0], X1, rev)
    Y12 = mvmult(v.next[2 if rev else 1], X2, rev)
    Y21 = mvmult(v.next[1 if rev else 2], X1, rev)
    Y22 = mvmult(v.next[3], X2, rev)

    return np.hstack((Y11 + Y12, Y21 + Y22)) if rev else np.vstack((Y11 + Y12, Y21 + Y22))


def mmmult(v: Node, w: Node) -> np.ndarray:
    zstack = lambda a, b, c, d: np.vstack((np.hstack((a, b)), np.hstack((c, d))))

    if v.rank == 0 or w.rank == 0:
        return np.zeros((v.side, w.side))

    if not v.next and not w.next:
        return v.U @ np.diag(v.D) @ v.V @ w.U @ np.diag(w.D) @ w.V

    if v.next and w.next:
        a1, a2, a3, a4 = v.next
        b1, b2, b3, b4 = w.next
        return zstack(
            mmmult(a1, b1) + mmmult(a2, b3),
            mmmult(a1, b2) + mmmult(a2, b4),
            mmmult(a3, b1) + mmmult(a4, b3),
            mmmult(a3, b2) + mmmult(a4, b4),
        )

    if not v.next and w.next:
        k = v.side
        b1, b2, b3, b4 = w.next
        U, V = v.U @ np.diag(v.D), v.V
        A1 = U[: k // 2, :] @ V[:, : k // 2]
        A2 = U[: k // 2, :] @ V[:, k // 2 :]
        A3 = U[k // 2 :, :] @ V[:, : k // 2]
        A4 = U[k // 2 :, :] @ V[:, k // 2 :]

        return zstack(
            mvmult(b1, A1, rev=True) + mvmult(b3, A2, rev=True),
            mvmult(b2, A1, rev=True) + mvmult(b4, A2, rev=True),
            mvmult(b1, A3, rev=True) + mvmult(b3, A4, rev=True),
            mvmult(b2, A3, rev=True) + mvmult(b4, A4, rev=True),
        )

    if v.next and not w.next:
        k = w.side
        a1, a2, a3, a4 = v.next
        U, V = w.U @ np.diag(w.D), w.V
        B1 = U[: k // 2, :] @ V[:, : k // 2]
        B2 = U[: k // 2, :] @ V[:, k // 2 :]
        B3 = U[k // 2 :, :] @ V[:, : k // 2]
        B4 = U[k // 2 :, :] @ V[:, k // 2 :]

        return zstack(
            mvmult(a1, B1) + mvmult(a2, B3),
            mvmult(a1, B2) + mvmult(a2, B4),
            mvmult(a3, B1) + mvmult(a4, B3),
            mvmult(a3, B2) + mvmult(a4, B4),
        )

# Check correctness
for A in As:
    v = CreateTree(A, r=1, eps=1e-3)
    X = np.random.random((A.shape[0], 1))
    print(np.allclose(A @ X, mvmult(v, X, rev=False)))
    print(np.allclose(X.T @ A, mvmult(v, X.T, rev=True)))

for A in As:
    v = CreateTree(A, r=1, eps=1e-3)
    print(np.allclose(A @ A, mmmult(v, v)))

for _ in range(25):
    k = 6
    A = np.random.random((2**k, 2**k))
    v = CreateTree(A, r=1, eps=1e-3)
    X = np.random.random((A.shape[0], 1))
    
    assert np.allclose(A @ X, mvmult(v, X, rev=False))
    assert np.allclose(X.T @ A, mvmult(v, X.T, rev=True))
    assert np.allclose(A @ A, mmmult(v, v))

from time import perf_counter

mvTimes = []
for A in As:
    v = CreateTree(A, r=1, eps=1e-3)
    X = np.random.random((A.shape[0], 1))
    s = perf_counter()
    AX = mvmult(v, X)
    e = perf_counter()

    assert np.allclose(AX, A @ X)
    mvTimes.append(e - s)


from scipy.optimize import curve_fit

f = lambda x, a, b: a * x**b
coeff, _ = curve_fit(f, [2 ** (3 * k) for k in (2, 3, 4)], mvTimes)
a, b = coeff
f_app = lambda x: f(x, a, b)

plt.scatter(
    [2 ** (3 * k) for k in (2, 3, 4)],
    mvTimes,
    marker="x",
    color="r",
    label="Measured times",
)
plt.plot(
    np.linspace(64, 4096, 100),
    f_app(np.linspace(64, 4096, 100)),
    color="k",
    ls="--",
    label=r"Fitted curve $t(n) = \alpha n^\beta$"
    + r" for $\alpha=$"
    + f"{a:.2e}"
    + r" and $\beta=$"
    + f"{b:.3f}",
)
plt.xlabel(r"Matrix side length $n$")
plt.ylabel("Time [s]")
plt.legend(loc="best")
plt.savefig("mvtimes.png", dpi=500)

mmTimes = []
for A in As:
    v = CreateTree(A, r=1, eps=1e-3)
    s = perf_counter()
    AA = mmmult(v, v)
    e = perf_counter()
    assert np.allclose(AA, A @ A)
    mmTimes.append(e - s)

f = lambda x, a, b: a * x**b
coeff, _ = curve_fit(f, [2 ** (3 * k) for k in (2, 3, 4)], mmTimes)
a, b = coeff
f_app = lambda x: f(x, a, b)

plt.scatter(
    [2 ** (3 * k) for k in (2, 3, 4)],
    mmTimes,
    marker="x",
    color="r",
    label="Measured times",
)
plt.plot(
    np.linspace(64, 4096, 100),
    f_app(np.linspace(64, 4096, 100)),
    color="k",
    ls="--",
    label=r"Fitted curve $t(n) = \alpha n^\beta$"
    + r" for $\alpha=$"
    + f"{a:.2e}"
    + r" and $\beta=$"
    + f"{b:.3f}",
)
plt.xlabel(r"Matrix side length $n$")
plt.ylabel("Time [s]")
plt.legend(loc="best")
plt.savefig("mmtimes.png", dpi=500)